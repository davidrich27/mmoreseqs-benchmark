K_SCORE=75
>>START_TIME=11/13/20:13:37:41:940733519
# mmseqs mmseqs_n1_hmm [BEGIN]
../set-env.sh: line 22: set-env_cluster.sh: No such file or directory
# BENCH_DIR: /home/dr120778/Wheeler-Labs/benchmarks/general-benchmark/runners/mmseqs
# SCRIPT_DIR: /home/dr120778/Wheeler-Labs/benchmarks/general-benchmark/runners
# setting environmental variables from 'set_env-db_profmark.sh'
# setting environmental variables from 'set_env-db_soeding.sh'
# setting environmental variables from 'set_env-my_benchmark.sh'
# setting environmental variables from 'set_env-db_test.sh'
# load profmark database, TASK_ID=.
# setting environmental variables from 'set-env_main.sh'
# load soeding database.
# load mybench database, TASK_ID=.
# load benchmark: my-benchmark...
# load mybench database, TASK_ID=.
mkdir: created directory ‘/home/dr120778/Wheeler-Labs/benchmarks/general-benchmark/runners/..//results//my-benchmark/mmseqs/mmseqs_n1_hmm/my-benchmark-k75-hhm/’
#         MY_ID:  my-benchmark-k75-hhm
#        JOB_ID:  my-benchmark-k75-hhm
#       TASK_ID:  0 of 1
#       PROGRAM:  mmseqs mmseqs_n1_hmm
#     BENCHMARK:  my-benchmark
#        TARGET:  /home/dr120778/Wheeler-Labs/benchmarks/general-benchmark/runners/..//db//my-benchmark//target.fasta
#     QUERY_HMM:  /home/dr120778/Wheeler-Labs/benchmarks/general-benchmark/runners/..//db//my-benchmark//query.hmm
#      QUERY_FA:  /home/dr120778/Wheeler-Labs/benchmarks/general-benchmark/runners/..//db//my-benchmark//query.cons.fasta
# TARGET_MMSEQS:  /home/dr120778/Wheeler-Labs/benchmarks/general-benchmark/runners/..//temp//my-benchmark/mmseqs//db//target
#  QUERY_MMSEQS:  /home/dr120778/Wheeler-Labs/benchmarks/general-benchmark/runners/..//temp//my-benchmark/mmseqs//db//query
#           ALN:  /home/dr120778/Wheeler-Labs/benchmarks/general-benchmark/runners/..//results//my-benchmark/mmseqs/mmseqs_n1_hmm/my-benchmark-k75-hhm//mmseqs_n1_hmm.k75.my-benchmark-k75-hhm
#        ALNOUT:  /home/dr120778/Wheeler-Labs/benchmarks/general-benchmark/runners/..//results//my-benchmark/mmseqs/mmseqs_n1_hmm/my-benchmark-k75-hhm//mmseqs_n1_hmm.k75.my-benchmark-k75-hhm.m8
#         KMERS:  (7)
#          KMER:  7
#         SPLIT:  1
#     MEM_LIMIT:  128000000
#       E_VALUE:  10000.0
#       K_SCORE:  75
#         SENSE:  5.7
#  MIN_UNGAPPED:  15
#      MAX_SEQS:  ls
#     NUM_ITERS:  1
#        E_PROF:  0.001
#           PCA:  1.0
#           PCB:  1.5
#       THREADS:  1
#       VERBOSE:  3
#    REMOVE_TMP:  0
#       TMP_DIR:  /home/dr120778/Wheeler-Labs/benchmarks/general-benchmark/runners/..//temp//my-benchmark/mmseqs/
usage: mmseqs search <i:queryDB> <i:targetDB> <o:alignmentDB> <tmpDir> [options]
 By Martin Steinegger <martin.steinegger@mpibpc.mpg.de>
options: prefilter:                  
 --comp-bias-corr INT         Correct for locally biased amino acid composition (range 0-1) [1]
 --add-self-matches BOOL      Artificially add entries of queries with themselves (for clustering) [0]
 --seed-sub-mat TWIN          Substitution matrix file for k-mer generation [nucl:nucleotide.out,aa:VTML80.out]
 -s FLOAT                     Sensitivity: 1.0 faster; 4.0 fast; 7.5 sensitive [5.700]
 -k INT                       k-mer length (0: automatically set to optimum) [7]
 --k-score INT                k-mer threshold for generating similar k-mer lists [75]
 --alph-size TWIN             Alphabet size (range 2-21) [nucl:5,aa:21]
 --max-seqs INT               Maximum results per query sequence allowed to pass the prefilter (affects sensitivity) [300]
 --split INT                  Split input into N equally distributed chunks. 0: set the best split automatically [1]
 --split-mode INT             0: split target db; 1: split query db; 2: auto, depending on main memory [2]
 --split-memory-limit BYTE    Set max memory per split. E.g. 800B, 5K, 10M, 1G. Default (0) to all available system memory [0]
 --diag-score BOOL            Use ungapped diagonal scoring during prefilter [1]
 --exact-kmer-matching INT    Extract only exact k-mers for matching (range 0-1) [0]
 --mask INT                   Mask sequences in k-mer stage: 0: w/o low complexity masking, 1: with low complexity masking [1]
 --mask-lower-case INT        Lowercase letters will be excluded from k-mer search 0: include region, 1: exclude region [0]
 --min-ungapped-score INT     Accept only matches with ungapped alignment score above threshold [15]
 --spaced-kmer-mode INT       0: use consecutive positions in k-mers; 1: use spaced k-mers [1]
 --spaced-kmer-pattern STR    User-specified spaced k-mer pattern []
 --local-tmp STR              Path where some of the temporary files will be created []
 --disk-space-limit BYTE      Set max disk space to use for reverse profile searches. E.g. 800B, 5K, 10M, 1G. Default (0) to all available disk space in the temp folder [0]
align:                      
 -a BOOL                      Add backtrace string (convert to alignments with mmseqs convertalis module) [0]
 --alignment-mode INT         How to compute the alignment: 0: automatic; 1: only score and end_pos; 2: also start_pos and cov; 3: also seq.id; 4: only ungapped alignment [2]
 --wrapped-scoring BOOL       Double the (nucleotide) query sequence during the scoring process to allow wrapped diagonal scoring around end and start [0]
 -e FLOAT                     List matches below this E-value (range 0.0-inf) [10000.000]
 --min-seq-id FLOAT           List matches above this sequence identity (for clustering) (range 0.0-1.0) [0.000]
 --min-aln-len INT            Minimum alignment length (range 0-INT_MAX) [0]
 --seq-id-mode INT            0: alignment length 1: shorter, 2: longer sequence [0]
 --alt-ali INT                Show up to this many alternative alignments [0]
 -c FLOAT                     List matches above this fraction of aligned (covered) residues (see --cov-mode) [0.000]
 --cov-mode INT               0: coverage of query and target
                              1: coverage of target
                              2: coverage of query
                              3: target seq. length has to be at least x% of query length
                              4: query seq. length has to be at least x% of target length
                              5: short seq. needs to be at least x% of the other seq. length [0]
 --realign BOOL               Compute more conservative, shorter alignments (scores and E-values not changed) [0]
 --max-rejected INT           Maximum rejected alignments before alignment calculation for a query is stopped [2147483647]
 --max-accept INT             Maximum accepted alignments before alignment calculation for a query is stopped [2147483647]
 --score-bias FLOAT           Score bias when computing SW alignment (in bits) [0.000]
 --gap-open INT               Gap open cost [11]
 --gap-extend INT             Gap extension cost [1]
 --zdrop INT                  Maximal allowed difference between score values before alignment is truncated  (nucleotide alignment only) [40]
profile:                    
 --pca FLOAT                  Pseudo count admixture strength [1.000]
 --pcb FLOAT                  Pseudo counts: Neff at half of maximum admixture (range 0.0-inf) [1.500]
 --mask-profile INT           Mask query sequence of profile using tantan [0,1] [1]
 --e-profile FLOAT            Include sequences matches with < e-value thr. into the profile (>=0.0) [0.100]
 --wg BOOL                    Use global sequence weighting for profile calculation [0]
 --filter-msa INT             Filter msa: 0: do not filter, 1: filter [1]
 --max-seq-id FLOAT           Reduce redundancy of output MSA using max. pairwise sequence identity [0.0,1.0] [0.900]
 --qid FLOAT                  Reduce diversity of output MSAs using min.seq. identity with query sequences [0.0,1.0] [0.000]
 --qsc FLOAT                  Reduce diversity of output MSAs using min. score per aligned residue with query sequences [-50.0,100.0] [-20.000]
 --cov FLOAT                  Filter output MSAs using min. fraction of query residues covered by matched sequences [0.0,1.0] [0.000]
 --diff INT                   Filter MSAs by selecting most diverse set of sequences, keeping at least this many seqs in each MSA block of length 50 [1000]
 --num-iterations INT         Number of iterative profile search iterations [1]
 --slice-search BOOL          For bigger profile DB, run iteratively the search by greedily swapping the search results [0]
misc:                       
 --rescore-mode INT           Rescore diagonals with:
                              0: Hamming distance
                              1: local alignment (score only)
                              2: local alignment
                              3: global alignment
                              4: longest alignment fullfilling window quality criterion [0]
 --allow-deletion BOOL        Allow deletions in a MSA [0]
 --min-length INT             Minimum codon number in open reading frames [30]
 --max-length INT             Maximum codon number in open reading frames [32734]
 --max-gaps INT               Maximum number of codons with gaps or unknown residues before an open reading frame is rejected [2147483647]
 --contig-start-mode INT      Contig start can be 0: incomplete, 1: complete, 2: both [2]
 --contig-end-mode INT        Contig end can be 0: incomplete, 1: complete, 2: both [2]
 --orf-start-mode INT         Orf fragment can be 0: from start to stop, 1: from any to stop, 2: from last encountered start to stop (no start in the middle) [1]
 --forward-frames STR         Comma-seperated list of frames on the forward strand to be extracted [1,2,3]
 --reverse-frames STR         Comma-seperated list of frames on the reverse strand to be extracted [1,2,3]
 --translation-table INT      1) CANONICAL, 2) VERT_MITOCHONDRIAL, 3) YEAST_MITOCHONDRIAL, 4) MOLD_MITOCHONDRIAL, 5) INVERT_MITOCHONDRIAL, 6) CILIATE
                              9) FLATWORM_MITOCHONDRIAL, 10) EUPLOTID, 11) PROKARYOTE, 12) ALT_YEAST, 13) ASCIDIAN_MITOCHONDRIAL, 14) ALT_FLATWORM_MITOCHONDRIAL
                              15) BLEPHARISMA, 16) CHLOROPHYCEAN_MITOCHONDRIAL, 21) TREMATODE_MITOCHONDRIAL, 22) SCENEDESMUS_MITOCHONDRIAL
                              23) THRAUSTOCHYTRIUM_MITOCHONDRIAL, 24) PTEROBRANCHIA_MITOCHONDRIAL, 25) GRACILIBACTERIA, 26) PACHYSOLEN, 27) KARYORELICT, 28) CONDYLOSTOMA
                               29) MESODINIUM, 30) PERTRICH, 31) BLASTOCRITHIDIA [1]
 --translate INT              Translate ORF to amino acid [0]
 --use-all-table-starts BOOL  Use all alteratives for a start codon in the genetic table, if false - only ATG (AUG) [0]
 --id-offset INT              Numeric ids in index file are offset by this value [0]
Error in argument --max-seqs
 --add-orf-stop BOOL          Add stop codon '*' at complete start and end [0]
 --search-type INT            Search type 0: auto 1: amino acid, 2: translated, 3: nucleotide, 4: translated nucleotide alignment [0]
 --start-sens FLOAT           Start sensitivity [4.000]
 --sens-steps INT             Number of search steps performed from --start-sens to -s [1]
common:                     
 --sub-mat TWIN               Substitution matrix file [nucl:nucleotide.out,aa:blosum62.out]
 --max-seq-len INT            Maximum sequence length [65535]
 --db-load-mode INT           Database preload mode 0: auto, 1: fread, 2: mmap, 3: mmap+touch [0]
 --threads INT                Number of CPU-cores used (all by default) [36]
 --compressed INT             Write compressed output [0]
 -v INT                       Verbosity level: 0: quiet, 1: +errors, 2: +warnings, 3: +info [3]
 --mpi-runner STR             Use MPI on compute cluster with this MPI command (e.g. "mpirun -np 42") []
 --force-reuse BOOL           Reuse tmp filse in tmp/latest folder ignoring parameters and version changes [0]
 --remove-tmp-files BOOL      Delete temporary files [0]
expert:                     
 --filter-hits BOOL           Filter hits by seq.id. and coverage [0]
 --sort-results INT           Sort results: 0: no sorting, 1: sort by E-value (Alignment) or seq.id. (Hamming) [0]
 --omit-consensus BOOL        Omit consensus sequence in alignment [0]
 --create-lookup INT          Create database lookup file (can be very large) [0]
 --chain-alignments INT       Chain overlapping alignments [0]
 --merge-query INT            Combine ORFs/split sequences to a single entry [1]
 --strand INT                 Strand selection only works for DNA/DNA search 0: reverse, 1: forward, 2: both [1]

examples:
 # Search multiple FASTA against FASTA (like BLASTP, TBLASTN, BLASTX, BLASTN --search-type 3, TBLASTX --search-type 2)
 mmseqs search queryDB targetDB resultDB tmp
 mmseqs convertalis queryDB targetDB resultDB result.m8
 
 # Iterative profile search (like PSI-BLAST)
 mmseqs search queryDB targetDB resultDB tmp --num-iterations 2
 
 # Profile search against small databases (e.g. PFAM, eggNOG)
 mmseqs databases PFAM pfam_db tmp
 mmseqs search queryDB pfam_db resultDB tmp
 
 # Exhaustive search against sequences or profiles (works for large DBs)
 mmseqs search queryDB targetDB resultDB tmp --slice-search
 
 # Increasing sensitivity search (from 2 to 7 in 3 steps)
 mmseqs search queryDB targetDB resultDB --start-sens 2 -s 7 --sens-steps 3
 
references:
 - Steinegger M, Soding J: MMseqs2 enables sensitive protein sequence searching for the analysis of massive data sets. Nature Biotechnology, 35(11), 1026-1028 (2017)

real	0m0.025s
user	0m0.003s
sys	0m0.000s
Input /home/dr120778/Wheeler-Labs/benchmarks/general-benchmark/runners/..//results//my-benchmark/mmseqs/mmseqs_n1_hmm/my-benchmark-k75-hhm//mmseqs_n1_hmm.k75.my-benchmark-k75-hhm does not exist.

real	0m0.025s
user	0m0.003s
sys	0m0.000s
# mmseqs mmseqs_n1_hmm [END]
>>END_TIME=11/13/20:13:37:42:515733738
